procedure main(argc, argv) {
    // Process arguments. Must have 3 arguments
    const jobFile := argv[1];
    const threadsCount := argv[2];

    // Open job file
    const jobFile := open(jobFile);
    const jobs := readJobData(job);
    
    // Process each job
    for job in jobs do
        // get job info from line
        // start job
        const result := processJob(job);
        // write report file and state plate binary file
        writeResult(result);
    end
}

procedure parseJob(line) {
    // line format: plateFile, duration, thermalDiffusivity, plateCellDimmensions, balancePoint
    const parts := split(line, ',');
    return {
        plateFile: parts[0],
        duration: parts[1],
        thermalDiffusivity: parts[2],
        plateCellDimmensions: parts[3],
        balancePoint: parts[4]
    };
}

procedure processJob(job) {
    const plate := readPlate(job.plateFile); // read matrix from binary file
    // simulate heat diffusion, functions returns the number of iterations and the final plate
    const result := simulate(plate, job.duration, job.thermalDiffusivity, job.plateCellDimmensions, job.balancePoint);
    return result;
}

procedure readPlate(plateFile) {
    const file := open(plateFile);
    const rows := readInt(file);
    const cols := readInt(file);
    const plate := newMatrix(rows, cols);
    for i := 0 to rows do
        for j := 0 to cols do
            plate[i][j] := readDouble(file);
        end
    end
    return plate;
}


procedure simulate(plate, duration, thermalDiffusivity, plateCellDimmensions, balancePoint) {
    shaered declare previusPlate := copy(plate);
    shared declare actualPlate := copy(plate);
    shaered declare iterarionCount := 0;
    declare team := createThreads(calculateNewTemperature, threadsCount);


    // // simulations itereation should run at least once, is necessary to check duration don't be 0.
    // do
    //     previusPlate = actualPlate; // save the acutal plate to compare with the next one
    //     // run the iteration
    //     actualPlate = iterarion(plate, duration, thermalDiffusivity, plateCellDimmensions);
    //     iterarionCount++;
    // end while (!isPlateBalanced(plate));

    // return the number of iterations and the final plate
    return {
        iterarionCount: iterarionCount,
        plate: actualPlate
    };
}


procedure calculateNewTemperature() {
    declare factor := (duration * thermalDiffusivity) / (plateDimmensions * plateDimmensions);
    declare localIsBalanced := 1;
    declare rows := rows(plate);
    declare cols := cols(plate);
    declare cellsProcessed := 0;
    declare totalCells := rows * cols;
    declare threadCount := threadsCount;
    declare currentPlateData := plate;
    declare newPlateData := newPlate;

    while (cellNumber < totalCells) {
        declare row := cellNumber / cols;
        declare col := cellNumber - (cellNumber / cols) * cols;

        if (row > 0 && row < rows - 1 && col > 0 && col < cols - 1) {
            declare left := currentPlateData[row][col - 1];
            declare right := currentPlateData[row][col + 1];
            declare up := currentPlateData[row - 1][col];
            declare down := currentPlateData[row + 1][col];
            declare cell := currentPlateData[row][col];

            declare newTemperature := cell + factor * (left + right + up + down - 4 * cell);
            newPlateData[row][col] := newTemperature;

            if (fabs(newTemperature - cell) > balancePoint) {
                localIsBalanced := 0;  // Se detecta que no estÃ¡ balanceado
            }
        }

        cellNumber += threadCount;
        cellsProcessed++;
    }
}

procedure isPlateBalanced(actualPlate, previousPlate, balancePoint) {
    const rows :=  rows(plate);
    const cols :=  cols(plate);
    for rowIndex := 0 to rows + 1 do
        for colIndex := 0 to cols + 1 do
            // if any cell is greater than the balance point, the plate is not balanced
            if (actualPlate[rowIndex][colIndex] - previousPlate[rowIndex][colIndex]) > balancePoint do 
                return false;
            end
        end
    end
    return true;
}